"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/loglevel";
exports.ids = ["vendor-chunks/loglevel"];
exports.modules = {
  /***/ "(ssr)/../node_modules/loglevel/lib/loglevel.js":
    /*!************************************************!*\
  !*** ../node_modules/loglevel/lib/loglevel.js ***!
  \************************************************/
    /***/ (module, exports, __webpack_require__) => {
      eval(
        'var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;\n/*\n* loglevel - https://github.com/pimterry/loglevel\n*\n* Copyright (c) 2013 Tim Perry\n* Licensed under the MIT license.\n*/ (function(root, definition) {\n    "use strict";\n    if (true) {\n        !(__WEBPACK_AMD_DEFINE_FACTORY__ = (definition),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \'function\' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else {}\n})(void 0, function() {\n    "use strict";\n    // Slightly dubious tricks to cut down minimized file size\n    var noop = function() {};\n    var undefinedType = "undefined";\n    var isIE = "undefined" !== undefinedType && typeof window.navigator !== undefinedType && /Trident\\/|MSIE /.test(window.navigator.userAgent);\n    var logMethods = [\n        "trace",\n        "debug",\n        "info",\n        "warn",\n        "error"\n    ];\n    // Cross-browser bind equivalent that works at least back to IE6\n    function bindMethod(obj, methodName) {\n        var method = obj[methodName];\n        if (typeof method.bind === "function") {\n            return method.bind(obj);\n        } else {\n            try {\n                return Function.prototype.bind.call(method, obj);\n            } catch (e) {\n                // Missing bind shim or IE8 + Modernizr, fallback to wrapping\n                return function() {\n                    return Function.prototype.apply.apply(method, [\n                        obj,\n                        arguments\n                    ]);\n                };\n            }\n        }\n    }\n    // Trace() doesn\'t print the message in IE, so for that case we need to wrap it\n    function traceForIE() {\n        if (console.log) {\n            if (console.log.apply) {\n                console.log.apply(console, arguments);\n            } else {\n                // In old IE, native console methods themselves don\'t have apply().\n                Function.prototype.apply.apply(console.log, [\n                    console,\n                    arguments\n                ]);\n            }\n        }\n        if (console.trace) console.trace();\n    }\n    // Build the best logging method possible for this env\n    // Wherever possible we want to bind, not wrap, to preserve stack traces\n    function realMethod(methodName) {\n        if (methodName === "debug") {\n            methodName = "log";\n        }\n        if (typeof console === undefinedType) {\n            return false; // No method possible, for now - fixed later by enableLoggingWhenConsoleArrives\n        } else if (methodName === "trace" && isIE) {\n            return traceForIE;\n        } else if (console[methodName] !== undefined) {\n            return bindMethod(console, methodName);\n        } else if (console.log !== undefined) {\n            return bindMethod(console, "log");\n        } else {\n            return noop;\n        }\n    }\n    // These private functions always need `this` to be set properly\n    function replaceLoggingMethods(level, loggerName) {\n        /*jshint validthis:true */ for(var i = 0; i < logMethods.length; i++){\n            var methodName = logMethods[i];\n            this[methodName] = i < level ? noop : this.methodFactory(methodName, level, loggerName);\n        }\n        // Define log.log as an alias for log.debug\n        this.log = this.debug;\n    }\n    // In old IE versions, the console isn\'t present until you first open it.\n    // We build realMethod() replacements here that regenerate logging methods\n    function enableLoggingWhenConsoleArrives(methodName, level, loggerName) {\n        return function() {\n            if (typeof console !== undefinedType) {\n                replaceLoggingMethods.call(this, level, loggerName);\n                this[methodName].apply(this, arguments);\n            }\n        };\n    }\n    // By default, we use closely bound real methods wherever possible, and\n    // otherwise we wait for a console to appear, and then try again.\n    function defaultMethodFactory(methodName, level, loggerName) {\n        /*jshint validthis:true */ return realMethod(methodName) || enableLoggingWhenConsoleArrives.apply(this, arguments);\n    }\n    function Logger(name, defaultLevel, factory) {\n        var self = this;\n        var currentLevel;\n        defaultLevel = defaultLevel == null ? "WARN" : defaultLevel;\n        var storageKey = "loglevel";\n        if (typeof name === "string") {\n            storageKey += ":" + name;\n        } else if (typeof name === "symbol") {\n            storageKey = undefined;\n        }\n        function persistLevelIfPossible(levelNum) {\n            var levelName = (logMethods[levelNum] || "silent").toUpperCase();\n            if ("undefined" === undefinedType || !storageKey) return;\n            // Use localStorage if available\n            try {\n                window.localStorage[storageKey] = levelName;\n                return;\n            } catch (ignore) {}\n            // Use session cookie as fallback\n            try {\n                window.document.cookie = encodeURIComponent(storageKey) + "=" + levelName + ";";\n            } catch (ignore) {}\n        }\n        function getPersistedLevel() {\n            var storedLevel;\n            if ("undefined" === undefinedType || !storageKey) return;\n            try {\n                storedLevel = window.localStorage[storageKey];\n            } catch (ignore) {}\n            // Fallback to cookies if local storage gives us nothing\n            if (typeof storedLevel === undefinedType) {\n                try {\n                    var cookie = window.document.cookie;\n                    var location = cookie.indexOf(encodeURIComponent(storageKey) + "=");\n                    if (location !== -1) {\n                        storedLevel = /^([^;]+)/.exec(cookie.slice(location))[1];\n                    }\n                } catch (ignore) {}\n            }\n            // If the stored level is not valid, treat it as if nothing was stored.\n            if (self.levels[storedLevel] === undefined) {\n                storedLevel = undefined;\n            }\n            return storedLevel;\n        }\n        function clearPersistedLevel() {\n            if ("undefined" === undefinedType || !storageKey) return;\n            // Use localStorage if available\n            try {\n                window.localStorage.removeItem(storageKey);\n                return;\n            } catch (ignore) {}\n            // Use session cookie as fallback\n            try {\n                window.document.cookie = encodeURIComponent(storageKey) + "=; expires=Thu, 01 Jan 1970 00:00:00 UTC";\n            } catch (ignore) {}\n        }\n        /*\n       *\n       * Public logger API - see https://github.com/pimterry/loglevel for details\n       *\n       */ self.name = name;\n        self.levels = {\n            "TRACE": 0,\n            "DEBUG": 1,\n            "INFO": 2,\n            "WARN": 3,\n            "ERROR": 4,\n            "SILENT": 5\n        };\n        self.methodFactory = factory || defaultMethodFactory;\n        self.getLevel = function() {\n            return currentLevel;\n        };\n        self.setLevel = function(level, persist) {\n            if (typeof level === "string" && self.levels[level.toUpperCase()] !== undefined) {\n                level = self.levels[level.toUpperCase()];\n            }\n            if (typeof level === "number" && level >= 0 && level <= self.levels.SILENT) {\n                currentLevel = level;\n                if (persist !== false) {\n                    persistLevelIfPossible(level);\n                }\n                replaceLoggingMethods.call(self, level, name);\n                if (typeof console === undefinedType && level < self.levels.SILENT) {\n                    return "No console available for logging";\n                }\n            } else {\n                throw "log.setLevel() called with invalid level: " + level;\n            }\n        };\n        self.setDefaultLevel = function(level) {\n            defaultLevel = level;\n            if (!getPersistedLevel()) {\n                self.setLevel(level, false);\n            }\n        };\n        self.resetLevel = function() {\n            self.setLevel(defaultLevel, false);\n            clearPersistedLevel();\n        };\n        self.enableAll = function(persist) {\n            self.setLevel(self.levels.TRACE, persist);\n        };\n        self.disableAll = function(persist) {\n            self.setLevel(self.levels.SILENT, persist);\n        };\n        // Initialize with the right level\n        var initialLevel = getPersistedLevel();\n        if (initialLevel == null) {\n            initialLevel = defaultLevel;\n        }\n        self.setLevel(initialLevel, false);\n    }\n    /*\n     *\n     * Top-level API\n     *\n     */ var defaultLogger = new Logger();\n    var _loggersByName = {};\n    defaultLogger.getLogger = function getLogger(name) {\n        if (typeof name !== "symbol" && typeof name !== "string" || name === "") {\n            throw new TypeError("You must supply a name when creating a logger.");\n        }\n        var logger = _loggersByName[name];\n        if (!logger) {\n            logger = _loggersByName[name] = new Logger(name, defaultLogger.getLevel(), defaultLogger.methodFactory);\n        }\n        return logger;\n    };\n    // Grab the current global log variable in case of overwrite\n    var _log = "undefined" !== undefinedType ? window.log : undefined;\n    defaultLogger.noConflict = function() {\n        if ("undefined" !== undefinedType && window.log === defaultLogger) {\n            window.log = _log;\n        }\n        return defaultLogger;\n    };\n    defaultLogger.getLoggers = function getLoggers() {\n        return _loggersByName;\n    };\n    // ES6 default export, for compatibility\n    defaultLogger["default"] = defaultLogger;\n    return defaultLogger;\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL2xvZ2xldmVsL2xpYi9sb2dsZXZlbC5qcyIsIm1hcHBpbmdzIjoiO0FBQUE7Ozs7O0FBS0EsR0FDQyxVQUFVQSxJQUFJLEVBQUVDLFVBQVU7SUFDdkI7SUFDQSxJQUFJLElBQTBDLEVBQUU7UUFDNUNDLG9DQUFPRCxVQUFVQTtBQUFBO0FBQUE7QUFBQTtBQUFBLGtHQUFDQTtJQUN0QixPQUFPLEVBSU47QUFDTCxHQUFFLFFBQU07SUFDSjtJQUVBLDBEQUEwRDtJQUMxRCxJQUFJTSxPQUFPLFlBQVk7SUFDdkIsSUFBSUMsZ0JBQWdCO0lBQ3BCLElBQUlDLE9BQU8sZ0JBQW1CRCxpQkFBbUIsT0FBT0UsT0FBT0MsU0FBUyxLQUFLSCxpQkFDekUsa0JBQWtCSSxJQUFJLENBQUNGLE9BQU9DLFNBQVMsQ0FBQ0UsU0FBUztJQUdyRCxJQUFJQyxhQUFhO1FBQ2I7UUFDQTtRQUNBO1FBQ0E7UUFDQTtLQUNIO0lBRUQsZ0VBQWdFO0lBQ2hFLFNBQVNDLFdBQVdDLEdBQUcsRUFBRUMsVUFBVTtRQUMvQixJQUFJQyxTQUFTRixHQUFHLENBQUNDLFdBQVc7UUFDNUIsSUFBSSxPQUFPQyxPQUFPQyxJQUFJLEtBQUssWUFBWTtZQUNuQyxPQUFPRCxPQUFPQyxJQUFJLENBQUNIO1FBQ3ZCLE9BQU87WUFDSCxJQUFJO2dCQUNBLE9BQU9JLFNBQVNDLFNBQVMsQ0FBQ0YsSUFBSSxDQUFDRyxJQUFJLENBQUNKLFFBQVFGO1lBQ2hELEVBQUUsT0FBT08sR0FBRztnQkFDUiw2REFBNkQ7Z0JBQzdELE9BQU87b0JBQ0gsT0FBT0gsU0FBU0MsU0FBUyxDQUFDRyxLQUFLLENBQUNBLEtBQUssQ0FBQ04sUUFBUTt3QkFBQ0Y7d0JBQUtTO3FCQUFVO2dCQUNsRTtZQUNKO1FBQ0o7SUFDSjtJQUVBLCtFQUErRTtJQUMvRSxTQUFTQztRQUNMLElBQUlDLFFBQVFyQixHQUFHLEVBQUU7WUFDYixJQUFJcUIsUUFBUXJCLEdBQUcsQ0FBQ2tCLEtBQUssRUFBRTtn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QUFFRDtRQUN0QztRQUVBLGtDQUFrQztRQUNsQyxJQUFJTyxlQUFlbEI7UUFDbkIsSUFBSWtCLGdCQUFnQixNQUFNO1lBQ3RCQSxlQUFlaEM7UUFDbkI7UUFDQUUsS0FBS3NCLFFBQVEsQ0FBQ1EsY0FBYztJQUM5QjtJQUVBOzs7O0tBSUMsR0FFRCxJQUFJQyxnQkFBZ0IsSUFBSW5DO0lBRXhCLElBQUlvQyxpQkFBaUIsQ0FBQztJQUN0QkQsY0FBY0UsU0FBUyxHQUFHLFNBQVNBLFVBQVVwQyxJQUFJO1FBQzdDLElBQUksT0FBUUEsU0FBUyxZQUFZLE9BQU9BLFNBQVMsWUFBYUEsU0FBUyxJQUFJO1lBQ3pFLE1BQU0sSUFBSXFDLFVBQVU7UUFDdEI7UUFFQSxJQUFJQyxTQUFTSCxjQUFjLENBQUNuQyxLQUFLO1FBQ2pDLElBQUksQ0FBQ3NDLFFBQVE7WUFDWEEsU0FBU0gsY0FBYyxDQUFDbkMsS0FBSyxHQUFHLElBQUlELE9BQ2xDQyxNQUFNa0MsY0FBY1YsUUFBUSxJQUFJVSxjQUFjdkMsYUFBYTtRQUMvRDtRQUNBLE9BQU8yQztJQUNYO0lBRUEsNERBQTREO0lBQzVELElBQUlDLE9BQU8sZ0JBQW1CeEUsZ0JBQWlCRSxPQUFPSixHQUFHLEdBQUd3QjtJQUM1RDZDLGNBQWNNLFVBQVUsR0FBRztRQUN2QixJQUFJLGdCQUFrQnpFLGlCQUNmRSxPQUFPSixHQUFHLEtBQUtxRSxlQUFlO1lBQ2pDakUsT0FBT0osR0FBRyxHQUFHMEU7UUFDakI7UUFFQSxPQUFPTDtJQUNYO0lBRUFBLGNBQWNPLFVBQVUsR0FBRyxTQUFTQTtRQUNoQyxPQUFPTjtJQUNYO0lBRUEsd0NBQXdDO0lBQ3hDRCxhQUFhLENBQUMsVUFBVSxHQUFHQTtJQUUzQixPQUFPQTtBQUNYIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGFja2h1YmIvLi4vbm9kZV9tb2R1bGVzL2xvZ2xldmVsL2xpYi9sb2dsZXZlbC5qcz84MmIwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4qIGxvZ2xldmVsIC0gaHR0cHM6Ly9naXRodWIuY29tL3BpbXRlcnJ5L2xvZ2xldmVsXG4qXG4qIENvcHlyaWdodCAoYykgMjAxMyBUaW0gUGVycnlcbiogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuKi9cbihmdW5jdGlvbiAocm9vdCwgZGVmaW5pdGlvbikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgZGVmaW5lKGRlZmluaXRpb24pO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBkZWZpbml0aW9uKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcm9vdC5sb2cgPSBkZWZpbml0aW9uKCk7XG4gICAgfVxufSh0aGlzLCBmdW5jdGlvbiAoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAvLyBTbGlnaHRseSBkdWJpb3VzIHRyaWNrcyB0byBjdXQgZG93biBtaW5pbWl6ZWQgZmlsZSBzaXplXG4gICAgdmFyIG5vb3AgPSBmdW5jdGlvbigpIHt9O1xuICAgIHZhciB1bmRlZmluZWRUeXBlID0gXCJ1bmRlZmluZWRcIjtcbiAgICB2YXIgaXNJRSA9ICh0eXBlb2Ygd2luZG93ICE9PSB1bmRlZmluZWRUeXBlKSAmJiAodHlwZW9mIHdpbmRvdy5uYXZpZ2F0b3IgIT09IHVuZGVmaW5lZFR5cGUpICYmIChcbiAgICAgICAgL1RyaWRlbnRcXC98TVNJRSAvLnRlc3Qod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQpXG4gICAgKTtcblxuICAgIHZhciBsb2dNZXRob2RzID0gW1xuICAgICAgICBcInRyYWNlXCIsXG4gICAgICAgIFwiZGVidWdcIixcbiAgICAgICAgXCJpbmZvXCIsXG4gICAgICAgIFwid2FyblwiLFxuICAgICAgICBcImVycm9yXCJcbiAgICBdO1xuXG4gICAgLy8gQ3Jvc3MtYnJvd3NlciBiaW5kIGVxdWl2YWxlbnQgdGhhdCB3b3JrcyBhdCBsZWFzdCBiYWNrIHRvIElFNlxuICAgIGZ1bmN0aW9uIGJpbmRNZXRob2Qob2JqLCBtZXRob2ROYW1lKSB7XG4gICAgICAgIHZhciBtZXRob2QgPSBvYmpbbWV0aG9kTmFtZV07XG4gICAgICAgIGlmICh0eXBlb2YgbWV0aG9kLmJpbmQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiBtZXRob2QuYmluZChvYmopO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQuY2FsbChtZXRob2QsIG9iaik7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgLy8gTWlzc2luZyBiaW5kIHNoaW0gb3IgSUU4ICsgTW9kZXJuaXpyLCBmYWxsYmFjayB0byB3cmFwcGluZ1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5hcHBseShtZXRob2QsIFtvYmosIGFyZ3VtZW50c10pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUcmFjZSgpIGRvZXNuJ3QgcHJpbnQgdGhlIG1lc3NhZ2UgaW4gSUUsIHNvIGZvciB0aGF0IGNhc2Ugd2UgbmVlZCB0byB3cmFwIGl0XG4gICAgZnVuY3Rpb24gdHJhY2VGb3JJRSgpIHtcbiAgICAgICAgaWYgKGNvbnNvbGUubG9nKSB7XG4gICAgICAgICAgICBpZiAoY29uc29sZS5sb2cuYXBwbHkpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBJbiBvbGQgSUUsIG5hdGl2ZSBjb25zb2xlIG1ldGhvZHMgdGhlbXNlbHZlcyBkb24ndCBoYXZlIGFwcGx5KCkuXG4gICAgICAgICAgICAgICAgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmFwcGx5KGNvbnNvbGUubG9nLCBbY29uc29sZSwgYXJndW1lbnRzXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbnNvbGUudHJhY2UpIGNvbnNvbGUudHJhY2UoKTtcbiAgICB9XG5cbiAgICAvLyBCdWlsZCB0aGUgYmVzdCBsb2dnaW5nIG1ldGhvZCBwb3NzaWJsZSBmb3IgdGhpcyBlbnZcbiAgICAvLyBXaGVyZXZlciBwb3NzaWJsZSB3ZSB3YW50IHRvIGJpbmQsIG5vdCB3cmFwLCB0byBwcmVzZXJ2ZSBzdGFjayB0cmFjZXNcbiAgICBmdW5jdGlvbiByZWFsTWV0aG9kKG1ldGhvZE5hbWUpIHtcbiAgICAgICAgaWYgKG1ldGhvZE5hbWUgPT09ICdkZWJ1ZycpIHtcbiAgICAgICAgICAgIG1ldGhvZE5hbWUgPSAnbG9nJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgY29uc29sZSA9PT0gdW5kZWZpbmVkVHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBObyBtZXRob2QgcG9zc2libGUsIGZvciBub3cgLSBmaXhlZCBsYXRlciBieSBlbmFibGVMb2dnaW5nV2hlbkNvbnNvbGVBcnJpdmVzXG4gICAgICAgIH0gZWxzZSBpZiAobWV0aG9kTmFtZSA9PT0gJ3RyYWNlJyAmJiBpc0lFKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJhY2VGb3JJRTtcbiAgICAgICAgfSBlbHNlIGlmIChjb25zb2xlW21ldGhvZE5hbWVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBiaW5kTWV0aG9kKGNvbnNvbGUsIG1ldGhvZE5hbWUpO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbnNvbGUubG9nICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBiaW5kTWV0aG9kKGNvbnNvbGUsICdsb2cnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBub29wO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gVGhlc2UgcHJpdmF0ZSBmdW5jdGlvbnMgYWx3YXlzIG5lZWQgYHRoaXNgIHRvIGJlIHNldCBwcm9wZXJseVxuXG4gICAgZnVuY3Rpb24gcmVwbGFjZUxvZ2dpbmdNZXRob2RzKGxldmVsLCBsb2dnZXJOYW1lKSB7XG4gICAgICAgIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbG9nTWV0aG9kcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIG1ldGhvZE5hbWUgPSBsb2dNZXRob2RzW2ldO1xuICAgICAgICAgICAgdGhpc1ttZXRob2ROYW1lXSA9IChpIDwgbGV2ZWwpID9cbiAgICAgICAgICAgICAgICBub29wIDpcbiAgICAgICAgICAgICAgICB0aGlzLm1ldGhvZEZhY3RvcnkobWV0aG9kTmFtZSwgbGV2ZWwsIGxvZ2dlck5hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGVmaW5lIGxvZy5sb2cgYXMgYW4gYWxpYXMgZm9yIGxvZy5kZWJ1Z1xuICAgICAgICB0aGlzLmxvZyA9IHRoaXMuZGVidWc7XG4gICAgfVxuXG4gICAgLy8gSW4gb2xkIElFIHZlcnNpb25zLCB0aGUgY29uc29sZSBpc24ndCBwcmVzZW50IHVudGlsIHlvdSBmaXJzdCBvcGVuIGl0LlxuICAgIC8vIFdlIGJ1aWxkIHJlYWxNZXRob2QoKSByZXBsYWNlbWVudHMgaGVyZSB0aGF0IHJlZ2VuZXJhdGUgbG9nZ2luZyBtZXRob2RzXG4gICAgZnVuY3Rpb24gZW5hYmxlTG9nZ2luZ1doZW5Db25zb2xlQXJyaXZlcyhtZXRob2ROYW1lLCBsZXZlbCwgbG9nZ2VyTmFtZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSB1bmRlZmluZWRUeXBlKSB7XG4gICAgICAgICAgICAgICAgcmVwbGFjZUxvZ2dpbmdNZXRob2RzLmNhbGwodGhpcywgbGV2ZWwsIGxvZ2dlck5hbWUpO1xuICAgICAgICAgICAgICAgIHRoaXNbbWV0aG9kTmFtZV0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBCeSBkZWZhdWx0LCB3ZSB1c2UgY2xvc2VseSBib3VuZCByZWFsIG1ldGhvZHMgd2hlcmV2ZXIgcG9zc2libGUsIGFuZFxuICAgIC8vIG90aGVyd2lzZSB3ZSB3YWl0IGZvciBhIGNvbnNvbGUgdG8gYXBwZWFyLCBhbmQgdGhlbiB0cnkgYWdhaW4uXG4gICAgZnVuY3Rpb24gZGVmYXVsdE1ldGhvZEZhY3RvcnkobWV0aG9kTmFtZSwgbGV2ZWwsIGxvZ2dlck5hbWUpIHtcbiAgICAgICAgLypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cbiAgICAgICAgcmV0dXJuIHJlYWxNZXRob2QobWV0aG9kTmFtZSkgfHxcbiAgICAgICAgICAgICAgIGVuYWJsZUxvZ2dpbmdXaGVuQ29uc29sZUFycml2ZXMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBMb2dnZXIobmFtZSwgZGVmYXVsdExldmVsLCBmYWN0b3J5KSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgY3VycmVudExldmVsO1xuICAgICAgZGVmYXVsdExldmVsID0gZGVmYXVsdExldmVsID09IG51bGwgPyBcIldBUk5cIiA6IGRlZmF1bHRMZXZlbDtcblxuICAgICAgdmFyIHN0b3JhZ2VLZXkgPSBcImxvZ2xldmVsXCI7XG4gICAgICBpZiAodHlwZW9mIG5hbWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgc3RvcmFnZUtleSArPSBcIjpcIiArIG5hbWU7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBuYW1lID09PSBcInN5bWJvbFwiKSB7XG4gICAgICAgIHN0b3JhZ2VLZXkgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHBlcnNpc3RMZXZlbElmUG9zc2libGUobGV2ZWxOdW0pIHtcbiAgICAgICAgICB2YXIgbGV2ZWxOYW1lID0gKGxvZ01ldGhvZHNbbGV2ZWxOdW1dIHx8ICdzaWxlbnQnKS50b1VwcGVyQ2FzZSgpO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IHVuZGVmaW5lZFR5cGUgfHwgIXN0b3JhZ2VLZXkpIHJldHVybjtcblxuICAgICAgICAgIC8vIFVzZSBsb2NhbFN0b3JhZ2UgaWYgYXZhaWxhYmxlXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgd2luZG93LmxvY2FsU3RvcmFnZVtzdG9yYWdlS2V5XSA9IGxldmVsTmFtZTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge31cblxuICAgICAgICAgIC8vIFVzZSBzZXNzaW9uIGNvb2tpZSBhcyBmYWxsYmFja1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHdpbmRvdy5kb2N1bWVudC5jb29raWUgPVxuICAgICAgICAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChzdG9yYWdlS2V5KSArIFwiPVwiICsgbGV2ZWxOYW1lICsgXCI7XCI7XG4gICAgICAgICAgfSBjYXRjaCAoaWdub3JlKSB7fVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBnZXRQZXJzaXN0ZWRMZXZlbCgpIHtcbiAgICAgICAgICB2YXIgc3RvcmVkTGV2ZWw7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gdW5kZWZpbmVkVHlwZSB8fCAhc3RvcmFnZUtleSkgcmV0dXJuO1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgc3RvcmVkTGV2ZWwgPSB3aW5kb3cubG9jYWxTdG9yYWdlW3N0b3JhZ2VLZXldO1xuICAgICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge31cblxuICAgICAgICAgIC8vIEZhbGxiYWNrIHRvIGNvb2tpZXMgaWYgbG9jYWwgc3RvcmFnZSBnaXZlcyB1cyBub3RoaW5nXG4gICAgICAgICAgaWYgKHR5cGVvZiBzdG9yZWRMZXZlbCA9PT0gdW5kZWZpbmVkVHlwZSkge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgdmFyIGNvb2tpZSA9IHdpbmRvdy5kb2N1bWVudC5jb29raWU7XG4gICAgICAgICAgICAgICAgICB2YXIgbG9jYXRpb24gPSBjb29raWUuaW5kZXhPZihcbiAgICAgICAgICAgICAgICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoc3RvcmFnZUtleSkgKyBcIj1cIik7XG4gICAgICAgICAgICAgICAgICBpZiAobG9jYXRpb24gIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgc3RvcmVkTGV2ZWwgPSAvXihbXjtdKykvLmV4ZWMoY29va2llLnNsaWNlKGxvY2F0aW9uKSlbMV07XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge31cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBJZiB0aGUgc3RvcmVkIGxldmVsIGlzIG5vdCB2YWxpZCwgdHJlYXQgaXQgYXMgaWYgbm90aGluZyB3YXMgc3RvcmVkLlxuICAgICAgICAgIGlmIChzZWxmLmxldmVsc1tzdG9yZWRMZXZlbF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBzdG9yZWRMZXZlbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gc3RvcmVkTGV2ZWw7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGNsZWFyUGVyc2lzdGVkTGV2ZWwoKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IHVuZGVmaW5lZFR5cGUgfHwgIXN0b3JhZ2VLZXkpIHJldHVybjtcblxuICAgICAgICAgIC8vIFVzZSBsb2NhbFN0b3JhZ2UgaWYgYXZhaWxhYmxlXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgd2luZG93LmxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKHN0b3JhZ2VLZXkpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfSBjYXRjaCAoaWdub3JlKSB7fVxuXG4gICAgICAgICAgLy8gVXNlIHNlc3Npb24gY29va2llIGFzIGZhbGxiYWNrXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgd2luZG93LmRvY3VtZW50LmNvb2tpZSA9XG4gICAgICAgICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KHN0b3JhZ2VLZXkpICsgXCI9OyBleHBpcmVzPVRodSwgMDEgSmFuIDE5NzAgMDA6MDA6MDAgVVRDXCI7XG4gICAgICAgICAgfSBjYXRjaCAoaWdub3JlKSB7fVxuICAgICAgfVxuXG4gICAgICAvKlxuICAgICAgICpcbiAgICAgICAqIFB1YmxpYyBsb2dnZXIgQVBJIC0gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9waW10ZXJyeS9sb2dsZXZlbCBmb3IgZGV0YWlsc1xuICAgICAgICpcbiAgICAgICAqL1xuXG4gICAgICBzZWxmLm5hbWUgPSBuYW1lO1xuXG4gICAgICBzZWxmLmxldmVscyA9IHsgXCJUUkFDRVwiOiAwLCBcIkRFQlVHXCI6IDEsIFwiSU5GT1wiOiAyLCBcIldBUk5cIjogMyxcbiAgICAgICAgICBcIkVSUk9SXCI6IDQsIFwiU0lMRU5UXCI6IDV9O1xuXG4gICAgICBzZWxmLm1ldGhvZEZhY3RvcnkgPSBmYWN0b3J5IHx8IGRlZmF1bHRNZXRob2RGYWN0b3J5O1xuXG4gICAgICBzZWxmLmdldExldmVsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBjdXJyZW50TGV2ZWw7XG4gICAgICB9O1xuXG4gICAgICBzZWxmLnNldExldmVsID0gZnVuY3Rpb24gKGxldmVsLCBwZXJzaXN0KSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBsZXZlbCA9PT0gXCJzdHJpbmdcIiAmJiBzZWxmLmxldmVsc1tsZXZlbC50b1VwcGVyQ2FzZSgpXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIGxldmVsID0gc2VsZi5sZXZlbHNbbGV2ZWwudG9VcHBlckNhc2UoKV07XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0eXBlb2YgbGV2ZWwgPT09IFwibnVtYmVyXCIgJiYgbGV2ZWwgPj0gMCAmJiBsZXZlbCA8PSBzZWxmLmxldmVscy5TSUxFTlQpIHtcbiAgICAgICAgICAgICAgY3VycmVudExldmVsID0gbGV2ZWw7XG4gICAgICAgICAgICAgIGlmIChwZXJzaXN0ICE9PSBmYWxzZSkgeyAgLy8gZGVmYXVsdHMgdG8gdHJ1ZVxuICAgICAgICAgICAgICAgICAgcGVyc2lzdExldmVsSWZQb3NzaWJsZShsZXZlbCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVwbGFjZUxvZ2dpbmdNZXRob2RzLmNhbGwoc2VsZiwgbGV2ZWwsIG5hbWUpO1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgPT09IHVuZGVmaW5lZFR5cGUgJiYgbGV2ZWwgPCBzZWxmLmxldmVscy5TSUxFTlQpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBcIk5vIGNvbnNvbGUgYXZhaWxhYmxlIGZvciBsb2dnaW5nXCI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aHJvdyBcImxvZy5zZXRMZXZlbCgpIGNhbGxlZCB3aXRoIGludmFsaWQgbGV2ZWw6IFwiICsgbGV2ZWw7XG4gICAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgc2VsZi5zZXREZWZhdWx0TGV2ZWwgPSBmdW5jdGlvbiAobGV2ZWwpIHtcbiAgICAgICAgICBkZWZhdWx0TGV2ZWwgPSBsZXZlbDtcbiAgICAgICAgICBpZiAoIWdldFBlcnNpc3RlZExldmVsKCkpIHtcbiAgICAgICAgICAgICAgc2VsZi5zZXRMZXZlbChsZXZlbCwgZmFsc2UpO1xuICAgICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHNlbGYucmVzZXRMZXZlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBzZWxmLnNldExldmVsKGRlZmF1bHRMZXZlbCwgZmFsc2UpO1xuICAgICAgICAgIGNsZWFyUGVyc2lzdGVkTGV2ZWwoKTtcbiAgICAgIH07XG5cbiAgICAgIHNlbGYuZW5hYmxlQWxsID0gZnVuY3Rpb24ocGVyc2lzdCkge1xuICAgICAgICAgIHNlbGYuc2V0TGV2ZWwoc2VsZi5sZXZlbHMuVFJBQ0UsIHBlcnNpc3QpO1xuICAgICAgfTtcblxuICAgICAgc2VsZi5kaXNhYmxlQWxsID0gZnVuY3Rpb24ocGVyc2lzdCkge1xuICAgICAgICAgIHNlbGYuc2V0TGV2ZWwoc2VsZi5sZXZlbHMuU0lMRU5ULCBwZXJzaXN0KTtcbiAgICAgIH07XG5cbiAgICAgIC8vIEluaXRpYWxpemUgd2l0aCB0aGUgcmlnaHQgbGV2ZWxcbiAgICAgIHZhciBpbml0aWFsTGV2ZWwgPSBnZXRQZXJzaXN0ZWRMZXZlbCgpO1xuICAgICAgaWYgKGluaXRpYWxMZXZlbCA9PSBudWxsKSB7XG4gICAgICAgICAgaW5pdGlhbExldmVsID0gZGVmYXVsdExldmVsO1xuICAgICAgfVxuICAgICAgc2VsZi5zZXRMZXZlbChpbml0aWFsTGV2ZWwsIGZhbHNlKTtcbiAgICB9XG5cbiAgICAvKlxuICAgICAqXG4gICAgICogVG9wLWxldmVsIEFQSVxuICAgICAqXG4gICAgICovXG5cbiAgICB2YXIgZGVmYXVsdExvZ2dlciA9IG5ldyBMb2dnZXIoKTtcblxuICAgIHZhciBfbG9nZ2Vyc0J5TmFtZSA9IHt9O1xuICAgIGRlZmF1bHRMb2dnZXIuZ2V0TG9nZ2VyID0gZnVuY3Rpb24gZ2V0TG9nZ2VyKG5hbWUpIHtcbiAgICAgICAgaWYgKCh0eXBlb2YgbmFtZSAhPT0gXCJzeW1ib2xcIiAmJiB0eXBlb2YgbmFtZSAhPT0gXCJzdHJpbmdcIikgfHwgbmFtZSA9PT0gXCJcIikge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJZb3UgbXVzdCBzdXBwbHkgYSBuYW1lIHdoZW4gY3JlYXRpbmcgYSBsb2dnZXIuXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxvZ2dlciA9IF9sb2dnZXJzQnlOYW1lW25hbWVdO1xuICAgICAgICBpZiAoIWxvZ2dlcikge1xuICAgICAgICAgIGxvZ2dlciA9IF9sb2dnZXJzQnlOYW1lW25hbWVdID0gbmV3IExvZ2dlcihcbiAgICAgICAgICAgIG5hbWUsIGRlZmF1bHRMb2dnZXIuZ2V0TGV2ZWwoKSwgZGVmYXVsdExvZ2dlci5tZXRob2RGYWN0b3J5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbG9nZ2VyO1xuICAgIH07XG5cbiAgICAvLyBHcmFiIHRoZSBjdXJyZW50IGdsb2JhbCBsb2cgdmFyaWFibGUgaW4gY2FzZSBvZiBvdmVyd3JpdGVcbiAgICB2YXIgX2xvZyA9ICh0eXBlb2Ygd2luZG93ICE9PSB1bmRlZmluZWRUeXBlKSA/IHdpbmRvdy5sb2cgOiB1bmRlZmluZWQ7XG4gICAgZGVmYXVsdExvZ2dlci5ub0NvbmZsaWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSB1bmRlZmluZWRUeXBlICYmXG4gICAgICAgICAgICAgICB3aW5kb3cubG9nID09PSBkZWZhdWx0TG9nZ2VyKSB7XG4gICAgICAgICAgICB3aW5kb3cubG9nID0gX2xvZztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkZWZhdWx0TG9nZ2VyO1xuICAgIH07XG5cbiAgICBkZWZhdWx0TG9nZ2VyLmdldExvZ2dlcnMgPSBmdW5jdGlvbiBnZXRMb2dnZXJzKCkge1xuICAgICAgICByZXR1cm4gX2xvZ2dlcnNCeU5hbWU7XG4gICAgfTtcblxuICAgIC8vIEVTNiBkZWZhdWx0IGV4cG9ydCwgZm9yIGNvbXBhdGliaWxpdHlcbiAgICBkZWZhdWx0TG9nZ2VyWydkZWZhdWx0J10gPSBkZWZhdWx0TG9nZ2VyO1xuXG4gICAgcmV0dXJuIGRlZmF1bHRMb2dnZXI7XG59KSk7XG4iXSwibmFtZXMiOlsicm9vdCIsImRlZmluaXRpb24iLCJkZWZpbmUiLCJhbWQiLCJtb2R1bGUiLCJleHBvcnRzIiwibG9nIiwibm9vcCIsInVuZGVmaW5lZFR5cGUiLCJpc0lFIiwid2luZG93IiwibmF2aWdhdG9yIiwidGVzdCIsInVzZXJBZ2VudCIsImxvZ01ldGhvZHMiLCJiaW5kTWV0aG9kIiwib2JqIiwibWV0aG9kTmFtZSIsIm1ldGhvZCIsImJpbmQiLCJGdW5jdGlvbiIsInByb3RvdHlwZSIsImNhbGwiLCJlIiwiYXBwbHkiLCJhcmd1bWVudHMiLCJ0cmFjZUZvcklFIiwiY29uc29sZSIsInRyYWNlIiwicmVhbE1ldGhvZCIsInVuZGVmaW5lZCIsInJlcGxhY2VMb2dnaW5nTWV0aG9kcyIsImxldmVsIiwibG9nZ2VyTmFtZSIsImkiLCJsZW5ndGgiLCJtZXRob2RGYWN0b3J5IiwiZGVidWciLCJlbmFibGVMb2dnaW5nV2hlbkNvbnNvbGVBcnJpdmVzIiwiZGVmYXVsdE1ldGhvZEZhY3RvcnkiLCJMb2dnZXIiLCJuYW1lIiwiZGVmYXVsdExldmVsIiwiZmFjdG9yeSIsInNlbGYiLCJjdXJyZW50TGV2ZWwiLCJzdG9yYWdlS2V5IiwicGVyc2lzdExldmVsSWZQb3NzaWJsZSIsImxldmVsTnVtIiwibGV2ZWxOYW1lIiwidG9VcHBlckNhc2UiLCJsb2NhbFN0b3JhZ2UiLCJpZ25vcmUiLCJkb2N1bWVudCIsImNvb2tpZSIsImVuY29kZVVSSUNvbXBvbmVudCIsImdldFBlcnNpc3RlZExldmVsIiwic3RvcmVkTGV2ZWwiLCJsb2NhdGlvbiIsImluZGV4T2YiLCJleGVjIiwic2xpY2UiLCJsZXZlbHMiLCJjbGVhclBlcnNpc3RlZExldmVsIiwicmVtb3ZlSXRlbSIsImdldExldmVsIiwic2V0TGV2ZWwiLCJwZXJzaXN0IiwiU0lMRU5UIiwic2V0RGVmYXVsdExldmVsIiwicmVzZXRMZXZlbCIsImVuYWJsZUFsbCIsIlRSQUNFIiwiZGlzYWJsZUFsbCIsImluaXRpYWxMZXZlbCIsImRlZmF1bHRMb2dnZXIiLCJfbG9nZ2Vyc0J5TmFtZSIsImdldExvZ2dlciIsIlR5cGVFcnJvciIsImxvZ2dlciIsIl9sb2ciLCJub0NvbmZsaWN0IiwiZ2V0TG9nZ2VycyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/loglevel/lib/loglevel.js\n',
      );

      /***/
    },
};
